# Agent CVE Coverage (Handbook Note)

Purpose: document how the agent and server ensure CVE coverage across all subsystems for ISO evidence.

## Flow (end-to-end)

1) **CVE mirror on server**  
   - Server mirrors OSV/OSV-compatible CVEs via `/api/security/cve` (manual trigger) and 24h interval.  
   - Ecosystems covered: Debian, Alpine, crates.io, Go, npm, Packagist, PyPI, RubyGems, Maven, NuGet, OSS-Fuzz (C/C++).

2) **Agent scan input**  
   - Agent sends installed packages and optional `cveScanPaths`/`scanPaths` (directories scanned for vulnerable packages/binaries) to `/api/agent/scan`.  
   - Server stores these paths in the package scan summary so operators can verify scope per host.

3) **Server-side matching (no agent-side CVE DB)**  
   - Server resolves the incoming package list into ecosystems (via `mapManagerToEcosystem`) and matches against the mirrored CVE table using `scanPackages(...)`.  
   - Matching is entirely server-side to guarantee a trusted CVE corpus and consistent version semantics.

4) **Results surfaced**  
   - `/security/{id}` shows last scan counts (packages/updates/security updates) **and the directories the agent scanned for CVEs** (from the stored summary).  
   - Vulnerability matches are listed with CVE IDs/severity; they reflect the server’s mirrored CVE dataset.

## Operator checkpoints

- Before/after scans, verify CVE mirror state via `GET /api/security/cve` and total CVE count.  
- In the VM detail page, confirm the “Directories scanned for CVEs” list matches your expected scope (e.g., `/usr/lib`, `/usr/local/bin`, container images, custom install paths).  
- To force an updated CVE corpus, run `POST /api/security/cve` then trigger a new agent scan.

## Why this is trustworthy

- CVE data source is centralized on the server (mirrored and versioned), not stale agent caches.  
- Package-to-ecosystem mapping and version comparison use consistent logic on the server.  
- Scan summaries persist the scanned paths for auditability; any gap in paths is visible to operators.
