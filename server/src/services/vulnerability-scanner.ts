import { PrismaClient, type Cve } from '@prisma/client'
import semver from 'semver'
import { prisma } from '../lib/prisma'

type OsvRangeEvent = {
  introduced?: string | null
  fixed?: string | null
  last_affected?: string | null
}

type OsvRange = {
  type?: string | null
  events?: OsvRangeEvent[]
}

type OsvAffectedEntry = {
  package?: { name?: string; ecosystem?: string | null }
  ranges?: OsvRange[]
  versions?: string[]
}

export type PackageInfo = {
  id: string
  machineId: string
  name: string
  version: string
  manager?: string | null
}

export type VulnerabilityMatchResult = {
  matchId: string
  cveId: string
  severity: string
  packageId: string
  packageName: string
  packageVersion: string
  description?: string | null
  score?: number | null
}

export function mapManagerToEcosystem(manager?: string | null): string | undefined {
  const normalized = (manager || '').toLowerCase()
  switch (normalized) {
    case 'npm':
    case 'yarn':
      return 'npm'
    case 'pypi':
    case 'pip':
      return 'PyPI'
    case 'go':
    case 'golang':
      return 'Go'
    case 'cargo':
    case 'rust':
      return 'crates.io'
    case 'composer':
      return 'Packagist'
    case 'gem':
    case 'rubygems':
      return 'RubyGems'
    case 'apt':
    case 'dpkg':
      return 'Debian'
    case 'apk':
      return 'Alpine'
    case 'rpm':
    case 'yum':
    case 'dnf':
      return 'Red Hat'
    case 'pacman':
      return 'Arch Linux'
    default:
      return undefined
  }
}

export function normalizeSeverityLabel(severity?: string | null): string {
  if (!severity) return 'unknown'
  const normalized = severity.toLowerCase()
  if (['critical', 'high', 'medium', 'low'].includes(normalized)) {
    return normalized
  }
  return severity.toLowerCase()
}

export function normalizeVersionInput(version: string): string {
  // Strip epoch prefixes (e.g., "1:1.2.3") and leading "v"
  return version.replace(/^[0-9]+:/, '').replace(/^v/, '')
}

export function compareVersions(a: string, b: string): number {
  const normA = normalizeVersionInput(a)
  const normB = normalizeVersionInput(b)
  const aValid = semver.valid(normA)
  const bValid = semver.valid(normB)

  if (aValid && bValid) {
    return semver.compare(normA, normB)
  }

  // Fallback to localeCompare with numeric sorting for non-semver versions
  return normA.localeCompare(normB, undefined, { numeric: true, sensitivity: 'base' })
}

function versionBetween(version: string, lower?: string | null, upper?: string | null, inclusiveUpper = false): boolean {
  const hasLower = !!lower
  const hasUpper = !!upper
  const lowerOk = hasLower ? compareVersions(version, lower!) >= 0 : true
  const upperOk = hasUpper ? (inclusiveUpper ? compareVersions(version, upper!) <= 0 : compareVersions(version, upper!) < 0) : true
  return lowerOk && upperOk
}

export function isVersionInRange(version: string, range: OsvRange): boolean {
  if (!range?.events || range.events.length === 0) return false

  let introduced: string | null = null

  for (const event of range.events) {
    if (event.introduced !== undefined) {
      introduced = event.introduced ?? null
      continue
    }

    if (event.fixed) {
      if (versionBetween(version, introduced, event.fixed, false)) {
        return true
      }
      introduced = null
    }

    if (event.last_affected) {
      if (versionBetween(version, introduced, event.last_affected, true)) {
        return true
      }
      introduced = null
    }
  }

  // Handle open-ended ranges (introduced with no closing event)
  if (introduced !== null) {
    return versionBetween(version, introduced, null, true)
  }

  return false
}

function versionsEqual(a: string, b: string): boolean {
  const normA = normalizeVersionInput(a)
  const normB = normalizeVersionInput(b)
  if (semver.valid(normA) && semver.valid(normB)) {
    return semver.eq(normA, normB)
  }
  return normA === normB
}

export function parseAffectedPayload(affected: string | null | undefined): OsvAffectedEntry[] {
  if (!affected) return []
  try {
    const parsed = JSON.parse(affected)
    return Array.isArray(parsed) ? parsed : []
  } catch {
    return []
  }
}

function isPackageAffectedByEntries(affectedEntries: OsvAffectedEntry[], pkg: PackageInfo): boolean {
  if (affectedEntries.length === 0) return false

  const packageName = pkg.name.toLowerCase()
  const pkgEcosystem = mapManagerToEcosystem(pkg.manager)

  for (const entry of affectedEntries) {
    const entryName = entry.package?.name?.toLowerCase()
    if (!entryName || entryName !== packageName) continue

    const entryEco = entry.package?.ecosystem
    if (entryEco && pkgEcosystem && entryEco.toLowerCase() !== pkgEcosystem.toLowerCase()) {
      continue
    }

    if (entry.versions?.some((v) => versionsEqual(v, pkg.version))) {
      return true
    }

    if (entry.ranges?.some((r) => isVersionInRange(pkg.version, r))) {
      return true
    }

    // If no version info is provided, assume the package is affected
    if ((!entry.ranges || entry.ranges.length === 0) && (!entry.versions || entry.versions.length === 0)) {
      return true
    }
  }

  return false
}

export function isCveAffectingPackage(cve: Pick<Cve, 'affected'>, pkg: PackageInfo): boolean {
  return isPackageAffectedByEntries(parseAffectedPayload(cve.affected), pkg)
}

function chunkArray<T>(items: T[], size: number): T[][] {
  if (items.length <= size) return [items]
  const chunks: T[][] = []
  for (let i = 0; i < items.length; i += size) {
    chunks.push(items.slice(i, i + size))
  }
  return chunks
}

export async function scanPackages(
  packages: PackageInfo[],
  prismaClient: PrismaClient = prisma
): Promise<{ matches: VulnerabilityMatchResult[]; created: number; removed: number }> {
  if (!packages || packages.length === 0) {
    return { matches: [], created: 0, removed: 0 }
  }

  const packageNameSet = new Set<string>()
  const packageIds: string[] = []
  for (const pkg of packages) {
    packageNameSet.add(pkg.name.toLowerCase())
    packageIds.push(pkg.id)
  }

  const packageNames = Array.from(packageNameSet)

  const existingMatches: Array<{ id: string; cveId: string; packageId: string }> = []
  for (const idChunk of chunkArray(packageIds, 900)) {
    const chunkMatches = await prismaClient.vulnerabilityMatch.findMany({
      where: { packageId: { in: idChunk } },
      select: { id: true, cveId: true, packageId: true }
    })
    existingMatches.push(...chunkMatches)
  }

  const existingByPackage = new Map<string, Array<{ id: string; cveId: string }>>()
  for (const match of existingMatches) {
    const list = existingByPackage.get(match.packageId) || []
    list.push({ id: match.id, cveId: match.cveId })
    existingByPackage.set(match.packageId, list)
  }

  const cveById = new Map<string, Cve>()
  for (const nameChunk of chunkArray(packageNames, 200)) {
    const cveFilters = nameChunk.map((name) => ({ affected: { contains: name } }))
    if (cveFilters.length === 0) continue
    const chunkCves = await prismaClient.cve.findMany({
      where: { OR: cveFilters },
      select: {
        id: true,
        severity: true,
        description: true,
        score: true,
        affected: true,
        publishedAt: true,
        createdAt: true,
        updatedAt: true
      }
    })
    for (const cve of chunkCves) {
      if (!cveById.has(cve.id)) {
        cveById.set(cve.id, cve)
      }
    }
  }

  const cves = Array.from(cveById.values())

  const matches: VulnerabilityMatchResult[] = []
  const cvesByPackageName = new Map<string, Cve[]>()
  for (const name of packageNames) {
    cvesByPackageName.set(name, [])
  }

  const affectedCache = new Map<string, OsvAffectedEntry[]>()
  for (const cve of cves) {
    const affectedEntries = parseAffectedPayload(cve.affected)
    affectedCache.set(cve.id, affectedEntries)
    if (affectedEntries.length === 0) continue

    const seenNames = new Set<string>()
    for (const entry of affectedEntries) {
      const entryName = entry.package?.name?.toLowerCase()
      if (!entryName || !cvesByPackageName.has(entryName) || seenNames.has(entryName)) {
        continue
      }
      cvesByPackageName.get(entryName)!.push(cve)
      seenNames.add(entryName)
    }
  }

  const newMatchMap = new Map<string, { cveId: string; packageId: string; machineId: string }>()
  const staleIds: string[] = []

  for (const pkg of packages) {
    const packageName = pkg.name.toLowerCase()
    const relevantCves = cvesByPackageName.get(packageName) || []
    const existingForPackage = existingByPackage.get(pkg.id) || []
    const existingSet = new Set(existingForPackage.map((m) => m.cveId))
    const activeSet = new Set<string>()

    for (const cve of relevantCves) {
      const affectedEntries = affectedCache.get(cve.id) || []
      if (!isPackageAffectedByEntries(affectedEntries, pkg)) continue

      activeSet.add(cve.id)
      if (!existingSet.has(cve.id)) {
        const matchKey = `${cve.id}:${pkg.id}`
        if (!newMatchMap.has(matchKey)) {
          newMatchMap.set(matchKey, { cveId: cve.id, packageId: pkg.id, machineId: pkg.machineId })
        }
      }

      matches.push({
        matchId: `${pkg.id}:${cve.id}`,
        cveId: cve.id,
        severity: normalizeSeverityLabel(cve.severity),
        packageId: pkg.id,
        packageName: pkg.name,
        packageVersion: pkg.version,
        description: cve.description,
        score: cve.score
      })
    }

    for (const existing of existingForPackage) {
      if (!activeSet.has(existing.cveId)) {
        staleIds.push(existing.id)
      }
    }
  }

  let created = 0
  let removed = 0

  const newMatches = Array.from(newMatchMap.values())
  for (const chunk of chunkArray(newMatches, 250)) {
    if (chunk.length === 0) continue
    const result = await prismaClient.vulnerabilityMatch.createMany({
      data: chunk
    })
    created += result.count
  }

  for (const chunk of chunkArray(staleIds, 500)) {
    if (chunk.length === 0) continue
    const result = await prismaClient.vulnerabilityMatch.deleteMany({
      where: { id: { in: chunk } }
    })
    removed += result.count
  }

  return { matches, created, removed }
}
