import { PrismaClient, type Cve } from '@prisma/client'
import semver from 'semver'
import { prisma } from '../lib/prisma'

type OsvRangeEvent = {
  introduced?: string | null
  fixed?: string | null
  last_affected?: string | null
}

type OsvRange = {
  type?: string | null
  events?: OsvRangeEvent[]
}

type OsvAffectedEntry = {
  package?: { name?: string; ecosystem?: string | null }
  ranges?: OsvRange[]
  versions?: string[]
}

export type PackageInfo = {
  id: string
  machineId: string
  name: string
  version: string
  manager?: string | null
}

export type VulnerabilityMatchResult = {
  matchId: string
  cveId: string
  severity: string
  packageId: string
  packageName: string
  packageVersion: string
  description?: string | null
  score?: number | null
}

export function mapManagerToEcosystem(manager?: string | null): string | undefined {
  const normalized = (manager || '').toLowerCase()
  switch (normalized) {
    case 'npm':
    case 'yarn':
      return 'npm'
    case 'pypi':
    case 'pip':
      return 'PyPI'
    case 'go':
    case 'golang':
      return 'Go'
    case 'cargo':
    case 'rust':
      return 'crates.io'
    case 'composer':
      return 'Packagist'
    case 'gem':
    case 'rubygems':
      return 'RubyGems'
    case 'apt':
    case 'dpkg':
      return 'Debian'
    case 'apk':
      return 'Alpine'
    case 'rpm':
    case 'yum':
    case 'dnf':
      return 'Red Hat'
    case 'pacman':
      return 'Arch Linux'
    default:
      return undefined
  }
}

export function normalizeSeverityLabel(severity?: string | null): string {
  if (!severity) return 'unknown'
  const normalized = severity.toLowerCase()
  if (['critical', 'high', 'medium', 'low'].includes(normalized)) {
    return normalized
  }
  return severity.toLowerCase()
}

export function normalizeVersionInput(version: string): string {
  // Strip epoch prefixes (e.g., "1:1.2.3") and leading "v"
  return version.replace(/^[0-9]+:/, '').replace(/^v/, '')
}

export function compareVersions(a: string, b: string): number {
  const normA = normalizeVersionInput(a)
  const normB = normalizeVersionInput(b)
  const aValid = semver.valid(normA)
  const bValid = semver.valid(normB)

  if (aValid && bValid) {
    return semver.compare(normA, normB)
  }

  // Fallback to localeCompare with numeric sorting for non-semver versions
  return normA.localeCompare(normB, undefined, { numeric: true, sensitivity: 'base' })
}

function versionBetween(version: string, lower?: string | null, upper?: string | null, inclusiveUpper = false): boolean {
  const hasLower = !!lower
  const hasUpper = !!upper
  const lowerOk = hasLower ? compareVersions(version, lower!) >= 0 : true
  const upperOk = hasUpper ? (inclusiveUpper ? compareVersions(version, upper!) <= 0 : compareVersions(version, upper!) < 0) : true
  return lowerOk && upperOk
}

export function isVersionInRange(version: string, range: OsvRange): boolean {
  if (!range?.events || range.events.length === 0) return false

  let introduced: string | null = null

  for (const event of range.events) {
    if (event.introduced !== undefined) {
      introduced = event.introduced ?? null
      continue
    }

    if (event.fixed) {
      if (versionBetween(version, introduced, event.fixed, false)) {
        return true
      }
      introduced = null
    }

    if (event.last_affected) {
      if (versionBetween(version, introduced, event.last_affected, true)) {
        return true
      }
      introduced = null
    }
  }

  // Handle open-ended ranges (introduced with no closing event)
  if (introduced !== null) {
    return versionBetween(version, introduced, null, true)
  }

  return false
}

function versionsEqual(a: string, b: string): boolean {
  const normA = normalizeVersionInput(a)
  const normB = normalizeVersionInput(b)
  if (semver.valid(normA) && semver.valid(normB)) {
    return semver.eq(normA, normB)
  }
  return normA === normB
}

export function parseAffectedPayload(affected: string | null | undefined): OsvAffectedEntry[] {
  if (!affected) return []
  try {
    const parsed = JSON.parse(affected)
    return Array.isArray(parsed) ? parsed : []
  } catch {
    return []
  }
}

export function isCveAffectingPackage(cve: Pick<Cve, 'affected'>, pkg: PackageInfo): boolean {
  const affectedEntries = parseAffectedPayload(cve.affected)
  if (affectedEntries.length === 0) return false

  const packageName = pkg.name.toLowerCase()
  const pkgEcosystem = mapManagerToEcosystem(pkg.manager)

  for (const entry of affectedEntries) {
    const entryName = entry.package?.name?.toLowerCase()
    if (!entryName || entryName !== packageName) continue

    const entryEco = entry.package?.ecosystem
    if (entryEco && pkgEcosystem && entryEco.toLowerCase() !== pkgEcosystem.toLowerCase()) {
      continue
    }

    if (entry.versions?.some((v) => versionsEqual(v, pkg.version))) {
      return true
    }

    if (entry.ranges?.some((r) => isVersionInRange(pkg.version, r))) {
      return true
    }

    // If no version info is provided, assume the package is affected
    if ((!entry.ranges || entry.ranges.length === 0) && (!entry.versions || entry.versions.length === 0)) {
      return true
    }
  }

  return false
}

export async function scanPackages(
  packages: PackageInfo[],
  prismaClient: PrismaClient = prisma
): Promise<{ matches: VulnerabilityMatchResult[]; created: number; removed: number }> {
  if (!packages || packages.length === 0) {
    return { matches: [], created: 0, removed: 0 }
  }

  const packageNames = Array.from(new Set(packages.map((p) => p.name.toLowerCase())))
  const cveFilters = packageNames.map((name) => ({ affected: { contains: name } }))
  const cves = cveFilters.length > 0
    ? await prismaClient.cve.findMany({ where: { OR: cveFilters } })
    : []

  const matches: VulnerabilityMatchResult[] = []
  let created = 0
  let removed = 0

  for (const pkg of packages) {
    const existingMatches = await prismaClient.vulnerabilityMatch.findMany({
      where: { packageId: pkg.id }
    })
    const existingSet = new Set(existingMatches.map((m) => m.cveId))
    const activeSet = new Set<string>()

    const relevantCves = cves.filter((cve) => {
      if (!cve.affected) return false
      return cve.affected.toLowerCase().includes(pkg.name.toLowerCase())
    })

    for (const cve of relevantCves) {
      if (!isCveAffectingPackage(cve, pkg)) continue

      activeSet.add(cve.id)
      if (!existingSet.has(cve.id)) {
        created += 1
      }

      await prismaClient.vulnerabilityMatch.upsert({
        where: {
          cveId_packageId: {
            cveId: cve.id,
            packageId: pkg.id
          }
        },
        update: {
          machineId: pkg.machineId
        },
        create: {
          cveId: cve.id,
          packageId: pkg.id,
          machineId: pkg.machineId
        }
      })

      matches.push({
        matchId: `${pkg.id}:${cve.id}`,
        cveId: cve.id,
        severity: normalizeSeverityLabel(cve.severity),
        packageId: pkg.id,
        packageName: pkg.name,
        packageVersion: pkg.version,
        description: cve.description,
        score: cve.score
      })
    }

    const stale = existingMatches.filter((m) => !activeSet.has(m.cveId))
    if (stale.length > 0) {
      await prismaClient.vulnerabilityMatch.deleteMany({
        where: { id: { in: stale.map((m) => m.id) } }
      })
      removed += stale.length
    }
  }

  return { matches, created, removed }
}
