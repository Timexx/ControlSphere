import { PrismaClient } from '@prisma/client'
import { prisma } from '../lib/prisma'
import { mapManagerToEcosystem, normalizeSeverityLabel } from './vulnerability-scanner'

type PackageRef = {
  name: string
  version?: string | null
  ecosystem: string
  manager?: string | null
}

type OsvSeverity = {
  type?: string
  score?: string
}

const OSV_BATCH_URL = 'https://api.osv.dev/v1/querybatch'
const OSV_GCS_LIST_URL = 'https://storage.googleapis.com/storage/v1/b/osv-vulnerabilities/o'
const OSV_GCS_DOWNLOAD_BASE = 'https://storage.googleapis.com/download/storage/v1/b/osv-vulnerabilities/o'
const DEFAULT_INTERVAL_MS = 1000 * 60 * 60 * 24 // 24 hours
const UPSERT_SLICE_SIZE = 50 // number of records to upsert per inner loop
const LIST_PAGE_SIZE = 500 // GCS object listing page size
const FETCH_CONCURRENCY = 4 // download a few vulnerability JSONs in parallel

let mirrorTimer: NodeJS.Timeout | null = null
let isRunning = false
const DEFAULT_ECOSYSTEMS = [
  'Debian',
  'Alpine',
  'crates.io',
  'Go',
  'npm',
  'Packagist',
  'PyPI',
  'RubyGems',
  'Maven',
  'NuGet',
  'OSS-Fuzz'
]

function pickSeverity(severities?: OsvSeverity[]): { label: string; score?: number } {
  if (!severities || severities.length === 0) {
    return { label: 'medium' }
  }

  let highest: { label: string; score?: number } = { label: 'medium' }

  for (const sev of severities) {
    const score = sev.score ? parseFloat(sev.score) : undefined
    if (score !== undefined) {
      const label =
        score >= 9 ? 'critical' :
        score >= 7 ? 'high' :
        score >= 4 ? 'medium' :
        'low'

      if (!highest.score || score > highest.score) {
        highest = { label, score }
      }
    } else if (sev.type) {
      const normalized = normalizeSeverityLabel(sev.type)
      if (['critical', 'high', 'medium', 'low'].includes(normalized) && highest.label !== 'critical') {
        highest = { label: normalized }
      }
    }
  }

  return highest
}

async function upsertCveFromOsv(vuln: any, client: PrismaClient) {
  const { label, score } = pickSeverity(vuln.severity)
  const publishedAt = vuln.published ? new Date(vuln.published) : new Date(vuln.modified || Date.now())

  await client.cve.upsert({
    where: { id: vuln.id },
    update: {
      description: vuln.summary || vuln.details || null,
      severity: label,
      score: score ?? null,
      publishedAt,
      affected: JSON.stringify(vuln.affected || []),
    },
    create: {
      id: vuln.id,
      description: vuln.summary || vuln.details || null,
      severity: label,
      score: score ?? null,
      publishedAt,
      affected: JSON.stringify(vuln.affected || []),
    }
  })
}

async function upsertCveBatch(vulns: any[], client: PrismaClient, batchSize = 200) {
  for (let i = 0; i < vulns.length; i += batchSize) {
    const slice = vulns.slice(i, i + batchSize)
    // Run sequentially to avoid SQLite timeouts with large transactions
    for (const v of slice) {
      const sev = pickSeverity(v.severity)
      await client.cve.upsert({
        where: { id: v.id },
        update: {
          description: v.summary || v.details || null,
          severity: sev.label,
          score: sev.score ?? null,
          publishedAt: v.published ? new Date(v.published) : new Date(v.modified || Date.now()),
          affected: JSON.stringify(v.affected || [])
        },
        create: {
          id: v.id,
          description: v.summary || v.details || null,
          severity: sev.label,
          score: sev.score ?? null,
          publishedAt: v.published ? new Date(v.published) : new Date(v.modified || Date.now()),
          affected: JSON.stringify(v.affected || [])
        }
      })
    }
  }
}

async function fetchPackageRefs(client: PrismaClient): Promise<PackageRef[]> {
  const packages = await client.vMPackage.findMany({
    select: { name: true, version: true, manager: true }
  })

  const seen = new Set<string>()
  const refs: PackageRef[] = []

  for (const pkg of packages) {
    const ecosystem = mapManagerToEcosystem(pkg.manager)
    if (!ecosystem) continue

    const key = `${ecosystem}:${pkg.name.toLowerCase()}`
    if (seen.has(key)) continue
    seen.add(key)

    refs.push({
      name: pkg.name,
      version: pkg.version,
      ecosystem,
      manager: pkg.manager
    })
  }

  return refs
}

async function listOsvObjects(ecosystem: string, pageToken?: string) {
  const params = new URLSearchParams({
    prefix: `${ecosystem}/`,
    maxResults: LIST_PAGE_SIZE.toString(),
    fields: 'items(name,mediaLink),nextPageToken'
  })
  if (pageToken) {
    params.set('pageToken', pageToken)
  }

  const res = await fetch(`${OSV_GCS_LIST_URL}?${params.toString()}`)
  if (!res.ok) {
    throw new Error(`Failed to list OSV objects for ${ecosystem}: status ${res.status}`)
  }
  const data = await res.json()
  const items: { name?: string; mediaLink?: string }[] = data.items || []
  return {
    objects: items.filter((i) => (i.name || '').endsWith('.json')),
    nextPageToken: data.nextPageToken as string | undefined
  }
}

async function fetchOsvRecord(objectName: string, mediaLink?: string) {
  const url = mediaLink || `${OSV_GCS_DOWNLOAD_BASE}/${encodeURIComponent(objectName)}?alt=media`
  const res = await fetch(url)
  if (!res.ok) {
    throw new Error(`Failed to fetch OSV record ${objectName}: status ${res.status}`)
  }
  return res.json()
}

async function mirrorEcosystemViaApi(ecosystem: string, client: PrismaClient): Promise<number> {
  let total = 0
  let pageToken: string | undefined

  do {
    const { objects, nextPageToken } = await listOsvObjects(ecosystem, pageToken)
    pageToken = nextPageToken

    for (let i = 0; i < objects.length; i += FETCH_CONCURRENCY) {
      const slice = objects.slice(i, i + FETCH_CONCURRENCY)
      const vulns = await Promise.all(
        slice.map(async (obj) => {
          try {
            return await fetchOsvRecord(obj.name!, obj.mediaLink)
          } catch (err) {
            console.warn(`OSV mirror: skipping record ${obj.name}: ${(err as Error)?.message || err}`)
            return null
          }
        })
      )

      const cleaned = vulns.filter(Boolean) as any[]
      if (cleaned.length > 0) {
        await upsertCveBatch(cleaned, client, UPSERT_SLICE_SIZE)
        total += cleaned.length
      }
    }
  } while (pageToken)

  return total
}

async function mirrorFull(client: PrismaClient, ecosystems: string[]) {
  let totalCves = 0
  const skipped: string[] = []
  for (const eco of ecosystems) {
    try {
      const processed = await mirrorEcosystemViaApi(eco, client)
      if (processed === 0) {
        skipped.push(eco)
        continue
      }
      totalCves += processed
    } catch (err: any) {
      console.warn(`OSV mirror: skipping ecosystem ${eco}: ${err?.message || err}`)
      skipped.push(eco)
      continue
    }
  }
  const errorMsg = skipped.length > 0 ? `Skipped ecosystems: ${skipped.join(', ')}` : null
  await client.cveMirrorState.upsert({
    where: { id: 'global' },
    update: {
      status: 'idle',
      lastSync: new Date(),
      ecosystems: JSON.stringify(ecosystems),
      mode: 'full',
      totalCves,
      error: errorMsg
    },
    create: {
      id: 'global',
      status: 'idle',
      lastSync: new Date(),
      ecosystems: JSON.stringify(ecosystems),
      mode: 'full',
      totalCves,
      error: errorMsg
    }
  })
}

async function mirrorOnce(client: PrismaClient) {
  const now = new Date()
  await client.cveMirrorState.upsert({
    where: { id: 'global' },
    update: { status: 'syncing', lastSync: now, error: null },
    create: { id: 'global', status: 'syncing', lastSync: now }
  })

  try {
    const modeEnv = (process.env.CVE_MIRROR_MODE || '').toLowerCase()
    const mode = modeEnv === 'full' ? 'full' : 'scoped'
    if (mode === 'full') {
      const ecosystems = (process.env.CVE_MIRROR_ECOSYSTEMS || '')
        .split(',')
        .map((e) => e.trim())
        .filter(Boolean)
      const ecoList = ecosystems.length > 0 ? ecosystems : DEFAULT_ECOSYSTEMS
      await mirrorFull(client, ecoList)
    } else {
      const packages = await fetchPackageRefs(client)
      if (packages.length === 0) {
        await client.cveMirrorState.update({
          where: { id: 'global' },
          data: { status: 'idle', lastSync: new Date(), error: null }
        })
        return
      }

      const batchSize = 100
      for (let i = 0; i < packages.length; i += batchSize) {
        const batch = packages.slice(i, i + batchSize)
        const response = await fetch(OSV_BATCH_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            queries: batch.map((pkg) => ({
              package: { name: pkg.name, ecosystem: pkg.ecosystem },
              version: pkg.version
            }))
          })
        })

        if (!response.ok) {
          throw new Error(`OSV mirror failed with status ${response.status}`)
        }

        const data = await response.json()
        for (const result of data.results || []) {
          for (const vuln of result.vulns || []) {
            await upsertCveFromOsv(vuln, client)
          }
        }
      }

      await client.cveMirrorState.update({
        where: { id: 'global' },
        data: { status: 'idle', lastSync: new Date(), error: null, mode: 'scoped' }
      })
    }
  } catch (error: any) {
    const message = error?.message || 'Unknown mirror error'
    console.error('CVE mirror failed:', message)
    await client.cveMirrorState.upsert({
      where: { id: 'global' },
      update: { status: 'error', lastSync: new Date(), error: message },
      create: { id: 'global', status: 'error', lastSync: new Date(), error: message }
    })
  }
}

export function startCveMirrorService(intervalMs: number = DEFAULT_INTERVAL_MS, client: PrismaClient = prisma) {
  if (mirrorTimer) return
  if (isRunning) return

  const run = async () => {
    if (isRunning) return
    isRunning = true
    try {
      await mirrorOnce(client)
    } finally {
      isRunning = false
    }
  }

  // Kick off immediately
  void run()

  mirrorTimer = setInterval(() => {
    void run()
  }, intervalMs)
}

export async function triggerCveMirrorOnce(client: PrismaClient = prisma) {
  if (isRunning) {
    return { accepted: false, status: 'syncing' as const }
  }
  isRunning = true
  try {
    await mirrorOnce(client)
    return { accepted: true, status: 'idle' as const }
  } finally {
    isRunning = false
  }
}

export async function getCveMirrorState(client: PrismaClient = prisma) {
  return client.cveMirrorState.findUnique({ where: { id: 'global' } })
}
